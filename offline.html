<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#4CAF50">
    <title>Offline - HealthConnect</title>
    <style>
        body {
            font-family: 'Poppins', sans-serif, Arial, Helvetica;
            background-color: #f5f5f5;
            color: #333;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
        }
        
        .offline-container {
            background-color: #fff;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            max-width: 90%;
            width: 400px;
            margin-bottom: 20px;
        }
        
        .offline-icon {
            font-size: 60px;
            color: #4CAF50;
            margin-bottom: 20px;
        }
        
        h1 {
            color: #4CAF50;
            margin-bottom: 15px;
        }
        
        p {
            margin-bottom: 25px;
            line-height: 1.6;
        }
        
        .btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 30px;
            font-weight: 600;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }
        
        .btn:hover {
            background-color: #3d8b40;
            transform: translateY(-3px);
        }

        .game-container {
            background-color: #fff;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            max-width: 90%;
            width: 400px;
            margin-top: 20px;
        }

        canvas {
            border: 2px solid #4CAF50;
            border-radius: 5px;
            background-color: #f9f9f9;
            touch-action: none;
        }

        .game-controls {
            margin-top: 15px;
        }

        .score {
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .touch-controls {
            display: none;
            margin-top: 15px;
            width: 100%;
            max-width: 300px;
        }

        .touch-row {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }

        .touch-btn {
            width: 60px;
            height: 60px;
            background-color: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 5px;
            font-size: 24px;
            color: #4CAF50;
            user-select: none;
        }

        .touch-btn:active {
            background-color: rgba(76, 175, 80, 0.5);
        }

        @media (max-width: 480px) {
            .game-container, .offline-container {
                width: 90%;
                padding: 15px;
            }
            
            canvas {
                width: 100%;
                height: auto;
                max-width: 300px;
                max-height: 300px;
            }
            
            .touch-controls {
                display: block;
            }
            
            h2 {
                font-size: 1.5rem;
            }
            
            p {
                font-size: 0.9rem;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="offline-container">
        <div class="offline-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="#4CAF50" viewBox="0 0 16 16">
                <path d="M10.706 3.294A12.545 12.545 0 0 0 8 3C5.259 3 2.723 3.882.663 5.379a.485.485 0 0 0-.048.736.518.518 0 0 0 .668.05A11.448 11.448 0 0 1 8 4c.63 0 1.249.05 1.852.148l.854-.854zM8 6c-1.905 0-3.68.56-5.166 1.526a.48.48 0 0 0-.063.745.525.525 0 0 0 .652.065 8.448 8.448 0 0 1 4.577-1.336 8.97 8.97 0 0 1 2.611.405l.915-.914A10.433 10.433 0 0 0 8 6zM2 8.82a.5.5 0 0 1 .402.511c-.5.703.192 1.265.417 1.56a.5.5 0 0 1-.94.337c-.26-.348-.598-1.038-.598-1.898 0-.26.022-.51.063-.749A.5.5 0 0 1 2 8.82zm10.015-3.828.854-.854A.5.5 0 0 1 13.707 4H14.5a.5.5 0 0 1 .5.5v1.293a.5.5 0 0 1-.146.354l-.854.854a9.007 9.007 0 0 1 0 3.654l.854.853a.5.5 0 0 1 .146.354V13.5a.5.5 0 0 1-.5.5h-.793a.5.5 0 0 1-.354-.146l-.853-.854a9.007 9.007 0 0 1-3.654 0l-.854.854a.5.5 0 0 1-.353.146h-.793a.5.5 0 0 1-.5-.5v-1.293a.5.5 0 0 1 .146-.354l.853-.853a9.007 9.007 0 0 1 0-3.654l-.853-.854a.5.5 0 0 1-.146-.353V4.5a.5.5 0 0 1 .5-.5h.793a.5.5 0 0 1 .354.146l.853.854a9.007 9.007 0 0 1 3.654 0zM8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zm0-1a3 3 0 1 1 0-6 3 3 0 0 1 0 6z"/>
            </svg>
        </div>
        <h1>You're Offline</h1>
        <p>It looks like you're not connected to the internet. Please check your connection and try again.</p>
        <button class="btn" onclick="window.location.reload()">Try Again</button>
    </div>
    
    <div class="game-container">
        <h2>Snake Game</h2>
        <p>Play while you wait for connection!</p>
        <div class="score">Score: <span id="score">0</span></div>
        <canvas id="gameCanvas" width="300" height="300"></canvas>
        <div class="game-controls">
            <button class="btn" id="startBtn">Start Game</button>
            <button class="btn" id="resetBtn">Reset Game</button>
        </div>
        <div class="touch-controls">
            <div class="touch-row">
                <div class="touch-btn" id="upBtn">↑</div>
            </div>
            <div class="touch-row">
                <div class="touch-btn" id="leftBtn">←</div>
                <div class="touch-btn" id="rightBtn">→</div>
            </div>
            <div class="touch-row">
                <div class="touch-btn" id="downBtn">↓</div>
            </div>
        </div>
        <p>Use arrow keys, WASD, or touch controls</p>
    </div>
    
    <script>
        // Check for network status changes
        window.addEventListener('online', () => {
            window.location.reload();
        });

        // Snake Game
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreElement = document.getElementById('score');
            const startBtn = document.getElementById('startBtn');
            const resetBtn = document.getElementById('resetBtn');
            
            // Touch controls
            const upBtn = document.getElementById('upBtn');
            const downBtn = document.getElementById('downBtn');
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');

            // Check if device is mobile
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Adjust canvas size for mobile
            function resizeCanvas() {
                if (isMobile) {
                    const containerWidth = document.querySelector('.game-container').clientWidth - 40; // Account for padding
                    const size = Math.min(300, containerWidth);
                    
                    // Keep the game grid intact by ensuring size is divisible by gridSize
                    const adjustedSize = Math.floor(size / gridSize) * gridSize;
                    
                    canvas.style.width = adjustedSize + 'px';
                    canvas.style.height = adjustedSize + 'px';
                }
            }

            // Game variables
            const gridSize = 15;
            const tileCount = canvas.width / gridSize;
            let snake = [];
            let food = { x: 0, y: 0 };
            let dx = gridSize;
            let dy = 0;
            let score = 0;
            let gameRunning = false;
            let gameInterval;
            let gameSpeed = 120;
            
            // For touch controls to prevent multiple direction changes in one frame
            let lastDirectionChange = Date.now();
            const directionChangeDelay = 100; // ms

            // Initialize the game
            function initGame() {
                // Create initial snake
                snake = [
                    { x: 10 * gridSize, y: 10 * gridSize },
                    { x: 9 * gridSize, y: 10 * gridSize },
                    { x: 8 * gridSize, y: 10 * gridSize }
                ];
                
                // Reset direction
                dx = gridSize;
                dy = 0;
                
                // Reset score
                score = 0;
                scoreElement.textContent = score;
                
                // Place initial food
                placeFood();
                
                // Draw initial state
                draw();
            }

            // Place food at random position
            function placeFood() {
                food.x = Math.floor(Math.random() * tileCount) * gridSize;
                food.y = Math.floor(Math.random() * tileCount) * gridSize;
                
                // Make sure food doesn't spawn on snake
                for (let i = 0; i < snake.length; i++) {
                    if (snake[i].x === food.x && snake[i].y === food.y) {
                        placeFood();
                        break;
                    }
                }
            }

            // Draw everything
            function draw() {
                // Clear canvas
                ctx.fillStyle = '#f9f9f9';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw snake
                ctx.fillStyle = '#4CAF50';
                for (let i = 0; i < snake.length; i++) {
                    ctx.fillRect(snake[i].x, snake[i].y, gridSize - 1, gridSize - 1);
                }
                
                // Draw food
                ctx.fillStyle = '#FF5722';
                ctx.fillRect(food.x, food.y, gridSize - 1, gridSize - 1);
            }

            // Move the snake
            function moveSnake() {
                // Create new head
                const head = { x: snake[0].x + dx, y: snake[0].y + dy };
                
                // Check for wall collision
                if (head.x < 0 || head.y < 0 || head.x >= canvas.width || head.y >= canvas.height) {
                    gameOver();
                    return;
                }
                
                // Check for self collision
                for (let i = 0; i < snake.length; i++) {
                    if (head.x === snake[i].x && head.y === snake[i].y) {
                        gameOver();
                        return;
                    }
                }
                
                // Add new head
                snake.unshift(head);
                
                // Check for food collision
                if (head.x === food.x && head.y === food.y) {
                    // Increase score
                    score++;
                    scoreElement.textContent = score;
                    
                    // Place new food
                    placeFood();
                    
                    // Increase speed slightly
                    if (gameSpeed > 50 && score % 5 === 0) {
                        gameSpeed -= 5;
                        clearInterval(gameInterval);
                        gameInterval = setInterval(gameLoop, gameSpeed);
                    }
                } else {
                    // Remove tail if no food eaten
                    snake.pop();
                }
                
                // Draw updated state
                draw();
            }

            // Game loop
            function gameLoop() {
                moveSnake();
            }

            // Game over
            function gameOver() {
                clearInterval(gameInterval);
                gameRunning = false;
                startBtn.textContent = 'Start Game';
                
                // Show game over message
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '20px Poppins';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over!', canvas.width / 2, canvas.height / 2);
                ctx.fillText('Score: ' + score, canvas.width / 2, canvas.height / 2 + 30);
            }

            // Change direction helper
            function changeDirection(newDx, newDy) {
                const now = Date.now();
                if (now - lastDirectionChange < directionChangeDelay) {
                    return; // Prevent too rapid direction changes
                }
                
                // Only change direction if it's not a 180-degree turn
                if ((dx !== -newDx || dx === 0) && (dy !== -newDy || dy === 0)) {
                    dx = newDx;
                    dy = newDy;
                    lastDirectionChange = now;
                }
            }

            // Handle keyboard input
            document.addEventListener('keydown', (e) => {
                if (!gameRunning) return;
                
                // Arrow keys and WASD
                switch (e.key) {
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        if (dy === 0) { // Prevent 180-degree turns
                            changeDirection(0, -gridSize);
                        }
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        if (dy === 0) {
                            changeDirection(0, gridSize);
                        }
                        break;
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        if (dx === 0) {
                            changeDirection(-gridSize, 0);
                        }
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        if (dx === 0) {
                            changeDirection(gridSize, 0);
                        }
                        break;
                }
                
                // Prevent scrolling with arrow keys
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                }
            });
            
            // Touch controls event listeners
            upBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameRunning && dy === 0) {
                    changeDirection(0, -gridSize);
                }
            });
            
            downBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameRunning && dy === 0) {
                    changeDirection(0, gridSize);
                }
            });
            
            leftBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameRunning && dx === 0) {
                    changeDirection(-gridSize, 0);
                }
            });
            
            rightBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameRunning && dx === 0) {
                    changeDirection(gridSize, 0);
                }
            });
            
            // Mouse/click events for touch buttons (for testing on desktop)
            upBtn.addEventListener('click', () => {
                if (gameRunning && dy === 0) {
                    changeDirection(0, -gridSize);
                }
            });
            
            downBtn.addEventListener('click', () => {
                if (gameRunning && dy === 0) {
                    changeDirection(0, gridSize);
                }
            });
            
            leftBtn.addEventListener('click', () => {
                if (gameRunning && dx === 0) {
                    changeDirection(-gridSize, 0);
                }
            });
            
            rightBtn.addEventListener('click', () => {
                if (gameRunning && dx === 0) {
                    changeDirection(gridSize, 0);
                }
            });
            
            // Swipe controls for mobile
            let touchStartX = 0;
            let touchStartY = 0;
            
            canvas.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                e.preventDefault(); // Prevent scrolling when touching the canvas
            }, { passive: false });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault(); // Prevent scrolling when touching the canvas
            }, { passive: false });
            
            canvas.addEventListener('touchend', (e) => {
                if (!gameRunning) return;
                
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;
                
                // Determine swipe direction based on the greatest difference
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    // Horizontal swipe
                    if (diffX > 0 && dx === 0) {
                        changeDirection(gridSize, 0); // Right
                    } else if (diffX < 0 && dx === 0) {
                        changeDirection(-gridSize, 0); // Left
                    }
                } else {
                    // Vertical swipe
                    if (diffY > 0 && dy === 0) {
                        changeDirection(0, gridSize); // Down
                    } else if (diffY < 0 && dy === 0) {
                        changeDirection(0, -gridSize); // Up
                    }
                }
                
                e.preventDefault();
            }, { passive: false });

            // Start/Pause button
            startBtn.addEventListener('click', () => {
                if (gameRunning) {
                    // Pause game
                    clearInterval(gameInterval);
                    gameRunning = false;
                    startBtn.textContent = 'Resume Game';
                } else {
                    // Start/Resume game
                    if (snake.length === 0) {
                        initGame();
                    }
                    gameRunning = true;
                    startBtn.textContent = 'Pause Game';
                    gameInterval = setInterval(gameLoop, gameSpeed);
                }
            });

            // Reset button
            resetBtn.addEventListener('click', () => {
                clearInterval(gameInterval);
                gameRunning = false;
                startBtn.textContent = 'Start Game';
                initGame();
            });

            // Handle window resize
            window.addEventListener('resize', resizeCanvas);
            
            // Initialize game on load
            resizeCanvas();
            initGame();
        });
    </script>
</body>
</html> 